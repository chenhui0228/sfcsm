this file describes the data model of the objects stored in mongodb

collection list :
[built by sysprobe]

memstat : contains the objects representing the status of a host mem at a given time

{
		"_id" : generated by db
        "timestamp" : int -> timestamp in second since epoch 
        "total" : int -> total size of memory 
        "used" : int -> amount of memory used
        "free" : int -> amount of free memory
        "buffers" : int -> amount of memory used for buffer
        "cached" : int -> amount of memory used for cached 
        "host" : DBRef -> host
}

swapstat : contains the objects representing the status of a host swap at a given time
{
		"_id" : generated by db
        "timestamp" : int -> timestamp in second since epoch 
        "total" : int -> total size of swap 
        "used" : int -> amount of swap used
        "free" : int -> amount of free swap
        "host" : DBRef -> host
}


disks : contains the objects representing the disks of the hosts

{
		"_id" : is set to host name+":"+logical name of the device
		"description" : string -> description of the disk
		"product" : string -> product name
		"manufacturer" : string -> vendor name
		"physical_id" : string -> physical id given by the system
		"logical_name" : string -> logical name
		"version" : string -> version of the disk
		"serial_number" : string -> serial number of the disk
		"size": disksize : int -> total size of the disk in byte
		"type" : disktype : string -> type of the disk(hdd,ssd)
		"diskmap" : DBRef ->
		"stat" : DBRef -> last stat of the disk (diskstat)
		"smart" : DBRef -> last smart info of the disk (disksmart)
}

diskmaps :
{
        "_id" : is set to host name+":"+logical name of the device
        "target_id" :
        "logical_name" :
        "device_id" :
}


diskstat : contains the objects representing the status of a disk at a given time

{
		"_id" : generated by db
        "timestamp" : int -> timestamp in second since epoch 
        "disk" : DBRef -> disk 
        "rrqm_s" : float -> The number of read requests merged per second  that  were queued to the device.
        "wrqm_s" : float -> The  number of write requests merged per second that were queued to the device.
        "r_s"  : float -> The number (after merges) of read requests completed  per second for the device.
        "w_s" : float -> The number (after merges) of write requests completed per second for the device.
        "rkB_s" : float -> The number of sectors (kilobytes)  read  from the device per second.
        "wkB_s" : float -> The  number  of sectors (kilobytes) written to the device per second.
}

partitions : contains the objects representing the partitions of disk
{
		"_id" : is set to host name+":"+ device name
		"dev" : string -> device name
		"mountpoint": string -> mountpoint
		"fs" : string -> filesystem type
		"stat" : DBRef -> last stat of the partition
}
            
partitionstat : contains the objects representing the status of a partition at a given time
{
		"_id" : generated by db
		"timestamp" : int -> timestamp in second since epoch 
		"total" : int -> total size of the partition,
		"used" : int -> amount of byte used
		"free" : int -> amount of byte free
		"partition" : DBRef -> partition
 }
               
               
cpus : contains the objects representing the cpus of the hosts
{
		"_id" : is set to host name+":"+physical id,
		"description" : string -> description of the cpu
		"product" : string -> product name
		"manufacturer" : string -> vendor name
		"physical_id" : string -> physical id given by the system
		"version" : string -> version of the cpu
		"frequency": int -> current frequency of the cpu in Hz
		"capacity" : int -> max frequency of the cpu in Hz
		"width" : int -> cpu width (in bit) (32 or 64 ...)
		"cores" : cores,
		"enabledcores" : enabledcores,
		"threads" : threads,
		"stat" : None
}




cpustat : contains the objects representing the status of a cpu (merged stat of all cpu of a host) at a given time
{
		"_id" : generated by db
		"timestamp" : int -> timestamp in second since epoch 
		"host" : DBRef -> host
		"user": float -> CPU time spent by normal programs and daemons
		"system": float -> CPU time spent by the kernel in system activities
		"idle": float -> time that the CPU or CPUs were idle and the system did not have an outstanding disk I/O request
		"iowait": float -> time that the CPU or CPUs were idle during which the system had an outstanding disk I/O request
		"irq": float -> CPU time spent handling interrupts
		"softirq" : float ->  CPU time spent handling "batched" interrupts
		"steal": float -> time spent in involuntary wait by the virtual CPU or CPUs while the hypervisor was servicing another virtual processor
		"guest" :float -> The time spent running a virtual CPU for guest operating systems under the control of the Linux kernel.
		"guest_nice" : float -> CPU time spent by nice programs
}



net  : contains the objects representing the network interfaces of a host
{
		"_id" : is set to host name+":"+logical name of the interface,
		"mtu":int -> mtu 
		"link" : string -> type of link (ether)
		"HWaddr" : string -> hardware address (mac) 
		"inet": {
			"addr" : string -> ipv4 address
		 	"mask" : string -> ipv4 mask
		}
		"inet6": {
			"addr" : string -> ipv6 address
		 	"mask" : string -> ipv6 mask
		}	
		"description" : string -> description
		"product" : string -> product name
		"manufacturer" : string -> vendor name
		"physical_id" : string -> physical id given by the system
		"logical_name" : string -> logical name
		"version" : string -> version of the interface
		"serial_number" : string -> serial number of the interface
		"size": int -> net interface current size,
		"capacity" : int ->  net interface capacity in bit/s,
		"stat" : DBRef -> netstat
}


netstat : contains the objects representing the status of a network interface

{
		"_id" : generated by db
		"network_interface" : DBRef -> network interface,
		"timestamp" : int -> timestamp in second since epoch
		"rx" : {
			"packets": int -> num of received packets
          	"errors":  int -> num of errors on received packets 
          	"dropped": int -> num of received packets dropped
          	"bytes" : int -> total num of bytes received
         	},
  		"tx" : {
			"packets": int -> num of sent packets
          	"errors":  int -> num of errors on sent packets 
          	"dropped": int -> num of sent packets dropped
          	"bytes" : int -> total num of bytes sent
         	}
}

hosts : collection of the cluster hosts
{
		"_id" : set to the host name
		"hostip" : string -> main IP address
		"timestamp" : int -> timestamp in second since epoch
		"mem" : DBRef -> RAM memory
		"swap" : DBref -> Swap
		"disks" : list of DBRef -> disks
		"partitions" : list of DBRef -> partitions
		"cpus" : list of DBRef -> cpus
		"cpus_stat" : DBRef -> cpustat,
		"network_interfaces" : list of DBRef -> network interface
}


[built by cephprobe]

mon
{
		"_id" : mon id 
        "host" : DBRef -> hosts
        "addr" : string -> ip address  
        "rank" : int -> rank
        "stat" : DBRef -> monstat
}

monstat
{
		"_id" : set to mon id + ":"+date of last update
        "mon" : DBRef -> mon
        "latency" : string ("float") 
        "last_updated" : "2014-02-19 13:50:07.544792", 
        "avail_percent" : int, 
        "skew" : string ("float"), 
        "kb_total" : int, 
        "time_health" : string health , 
        "kb_avail" : int, 
        "health" : string health, 
        "kb_used" : int, 
        "capacity_health" : string health
}

cluster
{
	"_id" : fsid of the cluster
	"election_epoch" : int -> ceph epoch counter
	"monmap" : {
					"epoch" : int -> ceph epoch,
		            "created" : string -> date of the creation of the monmap
		            "modified" : string -> date of the modification of the monmap
		            "mons" : list of DBRef -> mon (all mons of the cluster)
		            "quorum" :  list of DBRef -> mon (all mons in quorum)
              }
	"pgmap" : {} -> global info of pgs 
	"osdmap-info" : {} -> global info of osd 
	"name" : string -> cluster Name, 
	"health" : string -> overall status
}     
                   
clusterstat
{
		"_id" : generated by db
		"timestamp" : int -> timestamp in second since epoch 
		...
}

osd
{
		"_id" : int -> osd id
		"uuid" : string -> uuid
		"node" : DBRef ->  nodes
		"stat" :  DBRef -> osdstat
		"public_addr" : string -> public ip address
		"cluster_addr" : string -> cluster ip address
		"heartbeat_back_addr" : string -> heartbeat_back_addr
		"heartbeat_front_addr" :  string -> heartbeat_front_addr
		"down_stamp" : string -> stamp of last doown
		"laggy_probability" : float -> laggy probability
		"laggy_interval" : float -> laggy interval
		"host" :  DBRe -> hosts
		"partition" : DBRef -> partitions
}
		
osdstat
{
		"_id" : generated by db
		"timestamp" : int -> timestamp in second since epoch 
		"osd" : DBRef -> osd                      
		"up" : boolean 
		"in" : boolean
		"last_clean_begin" : string -> date of the begining of the last clean
		"last_clean_end" :  string -> date of the end of the last clean
		"up_from" :  string -> date
		"up_thru" :  string -> date 
		"down_at" :  string -> date
		"lost_at" :  string -> date
		"state" : string -> state of the osd
}


pools
info from osddump  
...

poolstat
info from df
{
		"_id" : generated by db
		"timestamp" : int -> timestamp in second since epoch 
		"pool" : DBRef -> pool
		...
}


pg
info from pgdump
...

[crush map components]
types
{
		"_id":  string -> type name, 
		"num" :  int -> type ceph id
}

nodes (osd or bucket)
for osd (device):
{
		"_id":  int -> osd id, 
		"name" :  string -> osd name
		"type" : DBRef -> type osd
}

for bucket :
{
		"_id" : int -> id of the bucket (negative)
		"name" : string -> bucket name
		"weight" : int -> weight associated to this bucket
		"type" : DBRef -> type
		"hash" : string -> hash algo used
		"alg" : string -> algo name for the placement (uniform | list | tree | straw)
		"items" : list of {
						"item" : DBRef -> node
						"weight" : int -> weight associated to this item
						"pos" : int -> position
					} 
}

rules
{
		"_id" : int -> id of the rule
		"name" : string -> rule name
		"ruleset" : int -> id of the rule set
		"type" : string -> rule type 
		"min_size" : int ->  If a pool makes fewer replicas than this number, CRUSH will NOT select this rule 
		"max_size" : int -> If a pool makes more replicas than this number, CRUSH will NOT select this rule 
		"steps" : list of {
						"op" : string -> operation name
						"item" : DBRef -> node
						"num" : int -> number of nodes 
						"type" : DBref -> type of node
					} 
}
                   
crushmap
{
		"_id" : string -> cluster Name,
		"types" : list of DBRef -> type,
		"nodes" : list of DBRef -> node,
		"rules" : list of DBRef -> rule,
		"tunables" : tunables as {}
}








